<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <title>VR Shooter MVP</title>
    <meta name="description" content="Simple VR shooter with pistol and random targets">
    <!-- Load A-Frame -->
    <script src="https://aframe.io/releases/1.7.0/aframe.min.js"></script>
  </head>
  <body>
    <!-- Main scene -->
    <a-scene vr-mode-ui="enabled: true" webxr="optionalFeatures: local-floor">
      <!-- Ground and sky for basic environment -->
      <a-plane rotation="-90 0 0" width="50" height="50" color="#7BC8A4"></a-plane>
      <a-sky color="#ECECEC"></a-sky>

      <!-- Player rig with camera -->
      <a-entity id="rig">
        <a-camera position="0 1.6 0"></a-camera>
      </a-entity>

      <!-- Oculus Quest controllers: left and right.  Attach gun-shooter to right hand.  -->
      <a-entity id="leftController" meta-touch-controls="hand: left"></a-entity>
      <a-entity id="rightController" meta-touch-controls="hand: right; model: false" gun-shooter="bulletSpeed: 12; cooldown: 250"></a-entity>

      <!-- Spawner for target spheres -->
      <a-entity id="gameManager" target-spawner="interval: 3000; maxTargets: 5"></a-entity>
    </a-scene>

    <!-- Game logic scripts -->
    <script>
      // Component that attaches a simple pistol model to the controller and handles shooting bullets.
      AFRAME.registerComponent('gun-shooter', {
        schema: {
          bulletSpeed: { type: 'number', default: 10 },
          cooldown: { type: 'number', default: 300 }
        },
        init: function () {
          this.lastShotTime = 0;
          // Build a simple pistol using primitives.  It will be a child of the controller entity (this.el).
          const handle = document.createElement('a-box');
          handle.setAttribute('depth', 0.06);
          handle.setAttribute('height', 0.2);
          handle.setAttribute('width', 0.04);
          handle.setAttribute('color', '#444');
          handle.setAttribute('position', '0 -0.05 -0.05');
          const barrel = document.createElement('a-cylinder');
          barrel.setAttribute('radius', 0.025);
          barrel.setAttribute('height', 0.25);
          barrel.setAttribute('color', '#222');
          barrel.setAttribute('rotation', '90 0 0');
          barrel.setAttribute('position', '0 0.03 -0.22');
          this.el.appendChild(handle);
          this.el.appendChild(barrel);

          // Bind shoot function to preserve context.
          this.shoot = this.shoot.bind(this);
          // Listen for triggerdown events from the controller.
          this.el.addEventListener('triggerdown', this.shoot);
          // Fallback: allow mouse click on desktop browsers to shoot for testing.
          window.addEventListener('click', this.shoot);
        },
        remove: function () {
          // Clean up event listeners when component is removed.
          this.el.removeEventListener('triggerdown', this.shoot);
          window.removeEventListener('click', this.shoot);
        },
        shoot: function () {
          const now = Date.now();
          if (now - this.lastShotTime < this.data.cooldown) {
            return;
          }
          this.lastShotTime = now;
          // Create bullet entity
          const bulletEl = document.createElement('a-sphere');
          bulletEl.setAttribute('radius', 0.02);
          bulletEl.setAttribute('color', '#FF0000');
          // Determine start position at the controller's world position
          const startPos = new AFRAME.THREE.Vector3();
          this.el.object3D.getWorldPosition(startPos);
          bulletEl.setAttribute('position', `${startPos.x} ${startPos.y} ${startPos.z}`);
          // Determine direction along controller's forward axis (Z) in world space
          const dir = new AFRAME.THREE.Vector3();
          this.el.object3D.getWorldDirection(dir);
          // Set bullet component with speed and direction
          bulletEl.setAttribute('bullet', `speed: ${this.data.bulletSpeed}; direction: ${dir.x} ${dir.y} ${dir.z}`);
          // Add bullet to scene
          this.el.sceneEl.appendChild(bulletEl);
        }
      });

      // Bullet component moves bullet forward and handles collisions with targets.
      AFRAME.registerComponent('bullet', {
        schema: {
          speed: { type: 'number', default: 10 },
          direction: { type: 'vec3' }
        },
        init: function () {
          // Record initial position to measure lifetime by distance travelled.
          this.startPos = this.el.object3D.position.clone();
        },
        tick: function (time, timeDelta) {
          // Move bullet along its direction each frame.
          const direction = new AFRAME.THREE.Vector3(this.data.direction.x, this.data.direction.y, this.data.direction.z);
          const moveStep = direction.multiplyScalar(this.data.speed * (timeDelta / 1000));
          this.el.object3D.position.add(moveStep);
          // Remove bullet after travelling 20 metres to free resources.
          if (this.el.object3D.position.distanceTo(this.startPos) > 20) {
            this.el.parentNode && this.el.parentNode.removeChild(this.el);
            return;
          }
          // Check for collisions against targets (class 'target').
          const targets = document.querySelectorAll('.target');
          const bulletPos = this.el.object3D.position;
          for (let i = 0; i < targets.length; i++) {
            const targetEl = targets[i];
            const targetPos = targetEl.object3D.position;
            // Simple spherical collision check: radii approx 0.25 (target) + 0.02 (bullet)
            if (bulletPos.distanceTo(targetPos) < 0.27) {
              // Remove target and bullet
              targetEl.parentNode && targetEl.parentNode.removeChild(targetEl);
              this.el.parentNode && this.el.parentNode.removeChild(this.el);
              return;
            }
          }
        }
      });

      // Spawns coloured spheres in front of the player at intervals.
      AFRAME.registerComponent('target-spawner', {
        schema: {
          interval: { type: 'number', default: 3000 },
          maxTargets: { type: 'number', default: 5 },
          distanceMin: { type: 'number', default: 3 },
          distanceMax: { type: 'number', default: 6 },
          verticalMin: { type: 'number', default: 1 },
          verticalMax: { type: 'number', default: 2 }
        },
        init: function () {
          this.activeTargets = [];
          this.spawnTarget = this.spawnTarget.bind(this);
          this.timer = setInterval(this.spawnTarget, this.data.interval);
        },
        spawnTarget: function () {
          // Limit number of simultaneous targets
          if (this.activeTargets.length >= this.data.maxTargets) return;
          const sceneEl = this.el.sceneEl;
          const cameraEl = sceneEl.camera.el;
          // Choose random distance and angle within a ±45° field
          const distance = this.data.distanceMin + Math.random() * (this.data.distanceMax - this.data.distanceMin);
          const angle = (Math.random() - 0.5) * (Math.PI / 2);
          const height = this.data.verticalMin + Math.random() * (this.data.verticalMax - this.data.verticalMin);
          // Determine world position of camera
          const camPos = new AFRAME.THREE.Vector3();
          cameraEl.object3D.getWorldPosition(camPos);
          // Determine forward direction of camera projected onto XZ plane
          const forward = new AFRAME.THREE.Vector3();
          cameraEl.object3D.getWorldDirection(forward);
          forward.y = 0;
          forward.normalize();
          // Determine a perpendicular vector to forward (to the right)
          const right = new AFRAME.THREE.Vector3().crossVectors(forward, new AFRAME.THREE.Vector3(0, 1, 0)).normalize();
          // Compute final position: forward * distance * cos(angle) + right * distance * sin(angle)
          const spawnPos = camPos.clone();
          const forwardComponent = forward.clone().multiplyScalar(distance * Math.cos(angle));
          const rightComponent = right.clone().multiplyScalar(distance * Math.sin(angle));
          spawnPos.add(forwardComponent).add(rightComponent);
          spawnPos.y += height;
          // Create target sphere
          const targetEl = document.createElement('a-sphere');
          targetEl.setAttribute('radius', 0.25);
          targetEl.setAttribute('position', `${spawnPos.x} ${spawnPos.y} ${spawnPos.z}`);
          // Random colour selection
          const colours = ['#EF2D5E', '#4CC3D9', '#FFC65D', '#7BC8A4', '#9370DB'];
          targetEl.setAttribute('color', colours[Math.floor(Math.random() * colours.length)]);
          targetEl.classList.add('target');
          sceneEl.appendChild(targetEl);
          this.activeTargets.push(targetEl);
          // Remove reference when target is removed from scene
          targetEl.addEventListener('removed', () => {
            const idx = this.activeTargets.indexOf(targetEl);
            if (idx !== -1) {
              this.activeTargets.splice(idx, 1);
            }
          });
        },
        remove: function () {
          clearInterval(this.timer);
        }
      });
    </script>
  </body>
</html>